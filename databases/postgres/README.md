## Postgres administration



|  Index Type |  Full Name | column type  |   |   |
|---|:-:|:-:|:-:|:-:|
| GiST  | Generalized Search Tree | `tsvector` _or_ `tsquery` |   |   |
| GIN  | Generalized Inverted Index  | `tsvector`  |   |   |
|   |   |   |   |   |

Per [Postgres Documentation](https://www.postgresql.org/docs/10/textsearch-indexes.html):

```SQL
CREATE INDEX name ON table USING GIN (column);
```
Creates a GIN (Generalized Inverted Index)-based index. The column must be of tsvector type.

```SQL
CREATE INDEX name ON table USING GIST (column);
```
Creates a GiST (Generalized Search Tree)-based index. The column can be of tsvector or tsquery type.

GiST indexes are _lossy_ because each document is represented in the index by a fixed-length signature. The signature is generated by hashing each word into a random bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct.

Lossiness causes performance degradation due to useless fetches of table records that turn out to be false matches. Since random access to table records is slow, this limits the usefulness of GiST indexes. The likelihood of false matches depends on several factors, in particular the number of unique words, so using dictionaries to reduce this number is recommended.

GIN indexes are the preferred text search index type. As inverted indexes, they contain an index entry for each word (lexeme), with a compressed list of matching locations. Multi-word searches can find the first match, then use the index to remove rows that are lacking additional words. GIN indexes store only the words (lexemes) of tsvector values, and not their weight labels. Thus a table row recheck is needed when using a query that involves weights.

`maintenance_work_mem`

Specifies the maximum amount of memory to be used by maintenance operations, such as VACUUM, CREATE INDEX, and ALTER TABLE ADD FOREIGN KEY. It defaults to 64 megabytes (64MB). Since only one of these operations can be executed at a time by a database session, and an installation normally doesn't have many of them running concurrently, it's safe to set this value [`maintenance_work_mem`] significantly larger than `work_mem`. Larger settings might improve performance for vacuuming and for restoring database dumps.

`work_mem`

Specifies the amount of memory to be used by internal sort operations and hash tables before writing to temporary disk files. The value defaults to four megabytes (4MB). Note that for a complex query, several sort or hash operations might be running in parallel; **each operation** will be allowed to use as much memory as this value specifies before it starts to write data into temporary files. Also, several running sessions could be doing such operations concurrently. `Therefore, the total memory used could be many times the value of work_mem`; it is necessary to keep this fact in mind when choosing the value. Sort operations are used for `ORDER BY`, `DISTINCT`, and `MERGE JOINs`. Hash tables are used in hash joins, hash-based aggregation, and hash-based processing of `IN` subqueries.

- [Full text search in milliseconds with PostgreSQL](https://blog.lateral.io/2015/05/full-text-search-in-milliseconds-with-postgresql/)
